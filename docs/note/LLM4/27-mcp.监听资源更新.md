## 27.监听资源更新

- 资源变化, 服务器主动通知;
- 代码; 创建 mcp 服务, server; 罗列资源列表; setRequestHandler, ListResourcesRequestSchema, watchDir, resources, files, file, filePath, stat, isFile, push, uri, name, mimeType, content;
- 测试; `npx @modelcontextprotocol/inspector`;
- `import { Server } from "@modelcontextprotocol/sdk/server/index.js";import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";import { ListResourcesRequestSchema, ReadResourceRequestSchema } from "@modelcontextprotocol/sdk/types.js";import { getWatchDir } from "./utils.js";import fs from "fs";import path from "path";import chokidar from "chokidar";const server = new Server({ name: "resource-watcher-demo", version: "0.1.0", desciption: "MCP资源列表变化监听演示", }, { capabilities: { resources: {}, }, });server.setRequestHandler(ListResourcesRequestSchema, async () => { const watchDir = getWatchDir(); const resources = []; try { const files = fs.readdirSync(watchDir); for (const file of files) { const filePath = path.join(watchDir, file); const stat = fs.statSync(filePath); if (stat.isFile()) { resources.push({ uri: `file://${filePath}`, name: file, mimeType: "text/plain", desciption: `文件: ${file}`, }); } } } catch (error) { console.error(`读取资源目录时出错: ${error.message}`); } return { resources, }; });const transport = new StdioServerTransport();await server.connect(transport);`
- 读取资源; ReadResourceRequestSchema, request, params, uri; filePath, replace, content, readFileSync, contents;
- 测试; `npx @modelcontextprotocol/inspector`;
- `server.setRequestHandler(ReadResourceRequestSchema, async (request) => { const { uri } = request.params; const filePath = uri.replace("file://", ""); const content = fs.readFileSync(filePath, "utf8"); return { contents: [{ uri, mimeType: "text/plain", text: content }] }; });`
- 创建监听器; initWatch, watchDir, watcher, chokidar, on, add, unlink, sendNotification; notification, method, notification/resources/list_changed, params;
- 测试; `npx @modelcontextprotocol/inspector`;
- `import { Server } from "@modelcontextprotocol/sdk/server/index.js";import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";import { ListResourcesRequestSchema, ReadResourceRequestSchema } from "@modelcontextprotocol/sdk/types.js";import { getWatchDir } from "./utils.js";import fs from "fs";import path from "path";import chokidar from "chokidar";const server = new Server({ name: "resource-watcher-demo", version: "0.1.0", desciption: "MCP资源列表变化监听演示", }, { capabilities: { resources: {} } });server.setRequestHandler(ListResourcesRequestSchema, async () => { const watchDir = getWatchDir(); const resources = []; try { const files = fs.readdirSync(watchDir); for (const file of files) { const filePath = path.join(watchDir, file); const stat = fs.statSync(filePath); if (stat.isFile()) { resources.push({ uri: `file://${filePath}`, name: file, mimeType: getMimeType(file), desciption: `文件: ${file}` }); } } } catch (error) { console.error(`读取资源目录时出错: ${error.message}`); } return { resources }; });function getMimeType(filename) { const ext = path.extname(filename).toLowerCase(); const mimeTypes = { ".txt": "text/plain", ".md": "text/markdown", ".js": "text/javascript", ".json": "application/json", ".html": "text/html", ".css": "text/css", ".xml": "application/xml" }; return mimeTypes[ext] || "text/plain"; }server.setRequestHandler(ReadResourceRequestSchema, async (request) => { const { uri } = request.params; const filePath = uri.replace("file://", ""); const filename = path.basename(filePath); const content = fs.readFileSync(filePath, "utf8"); return { contents: [{ uri, mimeType: getMimeType(filename), text: content }] }; });const sendNotification = () => { server.notification({ method: "notifications/resources/list_changed", params: {} }); };const initWatcher = () => { const watchDir = getWatchDir(); const watcher = chokidar.watch(watchDir, { ignored: /(^|[/\\])\../, persistent: true, ignoreInitial: true }); watcher.on("add", () => { sendNotification(); }).on("unlink", () => { sendNotification(); }); };const transport = new StdioServerTransport();await server.connect(transport);initWatcher();`

## 28. mcp Promps

- 步骤: 创建文件->LLM-config 配置->新增 header xx -> 完整阶段视频->重要内容笔记, 重要内容暂停记录, 普通内容完成整一段后记录 ->代码->测试->更新笔记->部署;
- MCP 目标: 通信标准; 大模型是最终信息的消费者;
- registerPrompt; description, arguments; name, description, required; request, args, code, language; codeContent, codeLanguage; messages, role, content; type, text;
- 测试; `npx @modelcontextprotocol/inspector`;
- `import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";const server = new McpServer({name:"resources-server",version:"0.1.0",});server.registerPrompt("总结代码",{description:"生成代码总结的prompt模板",arguments:[{name:"code",description:"需要总结的代码",required:false,},{name:"language",description:"代码对应的编程语言",required:false,},],},async(request)=>{const args=request.arguments||{};const{code,language}=args;const codeContent=code||`\n function calculateTotal(items) {\n let total = 0;\n for (const item of items) {\n total += item.price * item.quantity;\n }\n return total;\n `;const codeLanguage=language||"javascript";const messages=[{role:"user",content:{type:"text",text:`\n 请帮我总结以下${codeLanguage}代码的功能和主要逻辑：\n                \`\`\`${codeLanguage.toLowerCase()}\n ${codeContent}\n \`\`\`\n\n 请用中文回答，包括：\n 1. 代码的主要功能\n 2. 关键的逻辑流程 \n 3. 使用的主要技术或库\n 4. 可能的改进建议\n\n ${!code?"\n*注意：由于未提供代码参数，这里使用了示例代码进行演示。_":""}\n `,},},];return{messages,};});server.registerPrompt("生成测试的提示词模板",{description:"为指定函数生成测试用例的prompt模板",arguments:[{name:"function_name",description:"要测试的函数名称",required:false,},{name:"function_code",description:"函数的完整代码",required:false,},{name:"test_framework",description:"使用的测试框架 (例如: Jest, Mocha, Vitest)",required:false,},],},async(request)=>{const args=request.arguments||{};const{function_name,function_code,test_framework}=args;const functionName=function_name||"calculateTotal";const functionCode=function_code||`function calculateTotal(items) {\n if (!Array.isArray(items)) {\n throw new Error('参数必须是数组');\n }\n \n let total = 0;\n for (const item of items) {\n if (!item.price || !item.quantity) {\n throw new Error('每个商品必须有价格和数量');\n }\n total += item.price _ item.quantity;\n }\n return total;\n}`;const testFramework=test_framework||"Jest";return{messages:[{role:"user",content:{type:"text",text:`请为以下函数生成${testFramework}测试用例：\n\n函数名：${functionName}\n\n 函数代码：\n\`\`\`javascript\n${functionCode}\n\`\`\`\n\n请生成包括以下场景的测试用例：\n1. 正常情况的测试\n2. 边界情况的测试\n3. 错误情况的测试\n4. 输入验证的测试\n\n请用中文注释说明每个测试用例的目的。\n\n${!function_name&&!function_code?"\n*注意：由于未提供函数参数，这里使用了示例函数进行演示。*":""}`,},},],};});const transport=new StdioServerTransport();await server.connect(transport);
`
