## 27.监听资源更新

- 资源变化, 服务器主动通知;
- 代码; 创建 mcp 服务, server; 罗列资源列表; setRequestHandler, ListResourcesRequestSchema, watchDir, resources, files, file, filePath, stat, isFile, push, uri, name, mimeType, content;
- 测试; `npx @modelcontextprotocol/inspector`;
- `import { Server } from "@modelcontextprotocol/sdk/server/index.js";import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";import { ListResourcesRequestSchema, ReadResourceRequestSchema } from "@modelcontextprotocol/sdk/types.js";import { getWatchDir } from "./utils.js";import fs from "fs";import path from "path";import chokidar from "chokidar";const server = new Server({ name: "resource-watcher-demo", version: "0.1.0", desciption: "MCP资源列表变化监听演示", }, { capabilities: { resources: {}, }, });server.setRequestHandler(ListResourcesRequestSchema, async () => { const watchDir = getWatchDir(); const resources = []; try { const files = fs.readdirSync(watchDir); for (const file of files) { const filePath = path.join(watchDir, file); const stat = fs.statSync(filePath); if (stat.isFile()) { resources.push({ uri: `file://${filePath}`, name: file, mimeType: "text/plain", desciption: `文件: ${file}`, }); } } } catch (error) { console.error(`读取资源目录时出错: ${error.message}`); } return { resources, }; });const transport = new StdioServerTransport();await server.connect(transport);`
- 读取资源; ReadResourceRequestSchema, request, params, uri; filePath, replace, content, readFileSync, contents;
- 测试; `npx @modelcontextprotocol/inspector`;
- `server.setRequestHandler(ReadResourceRequestSchema, async (request) => { const { uri } = request.params; const filePath = uri.replace("file://", ""); const content = fs.readFileSync(filePath, "utf8"); return { contents: [{ uri, mimeType: "text/plain", text: content }] }; });`
- 创建监听器; initWatch, watchDir, watcher, chokidar, on, add, unlink, sendNotification; notification, method, notification/resources/list_changed, params;
- 测试; `npx @modelcontextprotocol/inspector`;
- `import { Server } from "@modelcontextprotocol/sdk/server/index.js";import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";import { ListResourcesRequestSchema, ReadResourceRequestSchema } from "@modelcontextprotocol/sdk/types.js";import { getWatchDir } from "./utils.js";import fs from "fs";import path from "path";import chokidar from "chokidar";const server = new Server({ name: "resource-watcher-demo", version: "0.1.0", desciption: "MCP资源列表变化监听演示", }, { capabilities: { resources: {} } });server.setRequestHandler(ListResourcesRequestSchema, async () => { const watchDir = getWatchDir(); const resources = []; try { const files = fs.readdirSync(watchDir); for (const file of files) { const filePath = path.join(watchDir, file); const stat = fs.statSync(filePath); if (stat.isFile()) { resources.push({ uri: `file://${filePath}`, name: file, mimeType: getMimeType(file), desciption: `文件: ${file}` }); } } } catch (error) { console.error(`读取资源目录时出错: ${error.message}`); } return { resources }; });function getMimeType(filename) { const ext = path.extname(filename).toLowerCase(); const mimeTypes = { ".txt": "text/plain", ".md": "text/markdown", ".js": "text/javascript", ".json": "application/json", ".html": "text/html", ".css": "text/css", ".xml": "application/xml" }; return mimeTypes[ext] || "text/plain"; }server.setRequestHandler(ReadResourceRequestSchema, async (request) => { const { uri } = request.params; const filePath = uri.replace("file://", ""); const filename = path.basename(filePath); const content = fs.readFileSync(filePath, "utf8"); return { contents: [{ uri, mimeType: getMimeType(filename), text: content }] }; });const sendNotification = () => { server.notification({ method: "notifications/resources/list_changed", params: {} }); };const initWatcher = () => { const watchDir = getWatchDir(); const watcher = chokidar.watch(watchDir, { ignored: /(^|[/\\])\../, persistent: true, ignoreInitial: true }); watcher.on("add", () => { sendNotification(); }).on("unlink", () => { sendNotification(); }); };const transport = new StdioServerTransport();await server.connect(transport);initWatcher();`

## 28. mcp Promps

- MCP 目标: 通信标准; 大模型是最终信息的消费者;
- registerPrompt; description, arguments; name, description, required; request, args, code, language; codeContent, codeLanguage; messages, role, content; type, text;
- 测试; `npx @modelcontextprotocol/inspector`;
- `import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";const server = new McpServer({name:"resources-server",version:"0.1.0",});server.registerPrompt("总结代码",{description:"生成代码总结的prompt模板",arguments:[{name:"code",description:"需要总结的代码",required:false,},{name:"language",description:"代码对应的编程语言",required:false,},],},async(request)=>{const args=request.arguments||{};const{code,language}=args;const codeContent=code||`\n function calculateTotal(items) {\n let total = 0;\n for (const item of items) {\n total += item.price * item.quantity;\n }\n return total;\n `;const codeLanguage=language||"javascript";const messages=[{role:"user",content:{type:"text",text:`\n 请帮我总结以下${codeLanguage}代码的功能和主要逻辑：\n                \`\`\`${codeLanguage.toLowerCase()}\n ${codeContent}\n \`\`\`\n\n 请用中文回答，包括：\n 1. 代码的主要功能\n 2. 关键的逻辑流程 \n 3. 使用的主要技术或库\n 4. 可能的改进建议\n\n ${!code?"\n*注意：由于未提供代码参数，这里使用了示例代码进行演示。_":""}\n `,},},];return{messages,};});server.registerPrompt("生成测试的提示词模板",{description:"为指定函数生成测试用例的prompt模板",arguments:[{name:"function_name",description:"要测试的函数名称",required:false,},{name:"function_code",description:"函数的完整代码",required:false,},{name:"test_framework",description:"使用的测试框架 (例如: Jest, Mocha, Vitest)",required:false,},],},async(request)=>{const args=request.arguments||{};const{function_name,function_code,test_framework}=args;const functionName=function_name||"calculateTotal";const functionCode=function_code||`function calculateTotal(items) {\n if (!Array.isArray(items)) {\n throw new Error('参数必须是数组');\n }\n \n let total = 0;\n for (const item of items) {\n if (!item.price || !item.quantity) {\n throw new Error('每个商品必须有价格和数量');\n }\n total += item.price _ item.quantity;\n }\n return total;\n}`;const testFramework=test_framework||"Jest";return{messages:[{role:"user",content:{type:"text",text:`请为以下函数生成${testFramework}测试用例：\n\n函数名：${functionName}\n\n 函数代码：\n\`\`\`javascript\n${functionCode}\n\`\`\`\n\n请生成包括以下场景的测试用例：\n1. 正常情况的测试\n2. 边界情况的测试\n3. 错误情况的测试\n4. 输入验证的测试\n\n请用中文注释说明每个测试用例的目的。\n\n${!function_name&&!function_code?"\n*注意：由于未提供函数参数，这里使用了示例函数进行演示。*":""}`,},},],};});const transport=new StdioServerTransport();await server.connect(transport);
`

## 29. SSE 基础知识

- 步骤: 创建文件->LLM-config 配置->新增 header xx -> 完整阶段视频->重要内容笔记, 重要内容暂停记录, 过长内容暂停记录, 普通内容完成整一段后记录 ->代码->测试->更新笔记->部署;
- SSE, 服务器发送事件, 基于 HTTP 单向通信;
- chokidar, express; 监听 watched 资源目录;
- 代码; server.js; get, mcp, setHeader, text/event-stream, no-cache, keep-alive, write, event:connected, data:${message};
- 代码; index.html; EventSource, addEventListener, connected, 打印; 测试;
- server.js: `import express from "express";import { watch } from "chokidar";import { join } from "path";import { fileURLToPath } from "url";import { dirname } from "path";const __filename = fileURLToPath(import.meta.url);const __dirname = dirname(__filename);const app = express();app.use(express.static(join(__dirname, "public")));app.get("/mcp", (req, res) => {res.setHeader("Content-Type", "text/event-stream");res.setHeader("Cache-Control", "no-cache");res.setHeader("Connection", "keep-alive");res.write("event: connected\n");res.write("data: 连接成功\n\n");});app.listen(3000, () => {console.log(`服务器已启动, 监听 3000 端口`);});`
- index.html; `<!DOCTYPE html><html><head><meta charset="UTF-8" /><title>资源变更监听器</title></head><body><h1>监听资源变化</h1><ul id="log"></ul><script>const eventSource=new EventSource("/mcp");eventSource.addEventListener("connected",event=>{console.log("连接成功",event);});eventSource.addEventListener("resource_changed",event=>{console.log("资源变化",event);});</script></body></html>`
- 代码; server.js; clients, Set, add, close, delete; watcher, persistent, ignoreInitial; all, payload, event, path, time; for, clients, write, event, resource_changed, data;
- 代码; log, createElement, textContent, getElementById, appendChild, li; addEventListener, resource_changed, log;
- server.js; `import express from "express";import { watch } from "chokidar";import { join } from "path";import { fileURLToPath } from "url";import { dirname } from "path";const __filename = fileURLToPath(import.meta.url);const __dirname = dirname(__filename);const app = express();const clients = new Set();app.use(express.static(join(__dirname, "public")));app.get("/mcp",(req,res)=>{res.setHeader("Content-Type","text/event-stream");res.setHeader("Cache-Control","no-cache");res.setHeader("Connection","keep-alive");res.write("event: connected\n");res.write("data: 连接成功\n\n");clients.add(res);req.on("close",()=>{clients.delete(res);});});const watcher = watch("watched",{persistent:true,ignoreInitial:true,});watcher.on("all",(event,path)=>{const payload={event,path,time:new Date().toISOString(),};for(const client of clients){client.write("event: resource_changed\n");client.write(`data: ${JSON.stringify(payload)}\n\n`);}});app.listen(3000,()=>{console.log(`服务器已启动, 监听 3000 端口`);});`
- index.html; `<!DOCTYPE html><html><head><meta charset="UTF-8" /><title>资源变更监听器</title></head><body><h1>监听资源变化</h1><ul id="log"></ul><script>function log(msg){const log=document.getElementById("log");const li=document.createElement("li");li.textContent=msg;log.appendChild(li);}const eventSource=new EventSource("/mcp");eventSource.addEventListener("connected",(event)=>{log(event.data);});eventSource.addEventListener("resource_changed",(event)=>{const info=JSON.parse(event.data);log(`资源发生变更: ${info.event} ${info.path} at ${info.time}`);});</script></body></html>`
