## 27.监听资源更新

- 资源变化, 服务器主动通知;
- 代码; 创建 mcp 服务, server; 罗列资源列表; setRequestHandler, ListResourcesRequestSchema, watchDir, resources, files, file, filePath, stat, isFile, push, uri, name, mimeType, content;
- 测试; `npx @modelcontextprotocol/inspector`;
- `import { Server } from "@modelcontextprotocol/sdk/server/index.js";import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";import { ListResourcesRequestSchema, ReadResourceRequestSchema } from "@modelcontextprotocol/sdk/types.js";import { getWatchDir } from "./utils.js";import fs from "fs";import path from "path";import chokidar from "chokidar";const server = new Server({ name: "resource-watcher-demo", version: "0.1.0", desciption: "MCP资源列表变化监听演示", }, { capabilities: { resources: {}, }, });server.setRequestHandler(ListResourcesRequestSchema, async () => { const watchDir = getWatchDir(); const resources = []; try { const files = fs.readdirSync(watchDir); for (const file of files) { const filePath = path.join(watchDir, file); const stat = fs.statSync(filePath); if (stat.isFile()) { resources.push({ uri: `file://${filePath}`, name: file, mimeType: "text/plain", desciption: `文件: ${file}`, }); } } } catch (error) { console.error(`读取资源目录时出错: ${error.message}`); } return { resources, }; });const transport = new StdioServerTransport();await server.connect(transport);`
- 读取资源; ReadResourceRequestSchema, request, params, uri; filePath, replace, content, readFileSync, contents;
- 测试; `npx @modelcontextprotocol/inspector`;
- `server.setRequestHandler(ReadResourceRequestSchema, async (request) => { const { uri } = request.params; const filePath = uri.replace("file://", ""); const content = fs.readFileSync(filePath, "utf8"); return { contents: [{ uri, mimeType: "text/plain", text: content }] }; });`
- 创建监听器; initWatch, watchDir, watcher, chokidar, on, add, unlink, sendNotification; notification, method, notification/resources/list_changed, params;
- 测试; `npx @modelcontextprotocol/inspector`;
- `import { Server } from "@modelcontextprotocol/sdk/server/index.js";import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";import { ListResourcesRequestSchema, ReadResourceRequestSchema } from "@modelcontextprotocol/sdk/types.js";import { getWatchDir } from "./utils.js";import fs from "fs";import path from "path";import chokidar from "chokidar";const server = new Server({ name: "resource-watcher-demo", version: "0.1.0", desciption: "MCP资源列表变化监听演示", }, { capabilities: { resources: {} } });server.setRequestHandler(ListResourcesRequestSchema, async () => { const watchDir = getWatchDir(); const resources = []; try { const files = fs.readdirSync(watchDir); for (const file of files) { const filePath = path.join(watchDir, file); const stat = fs.statSync(filePath); if (stat.isFile()) { resources.push({ uri: `file://${filePath}`, name: file, mimeType: getMimeType(file), desciption: `文件: ${file}` }); } } } catch (error) { console.error(`读取资源目录时出错: ${error.message}`); } return { resources }; });function getMimeType(filename) { const ext = path.extname(filename).toLowerCase(); const mimeTypes = { ".txt": "text/plain", ".md": "text/markdown", ".js": "text/javascript", ".json": "application/json", ".html": "text/html", ".css": "text/css", ".xml": "application/xml" }; return mimeTypes[ext] || "text/plain"; }server.setRequestHandler(ReadResourceRequestSchema, async (request) => { const { uri } = request.params; const filePath = uri.replace("file://", ""); const filename = path.basename(filePath); const content = fs.readFileSync(filePath, "utf8"); return { contents: [{ uri, mimeType: getMimeType(filename), text: content }] }; });const sendNotification = () => { server.notification({ method: "notifications/resources/list_changed", params: {} }); };const initWatcher = () => { const watchDir = getWatchDir(); const watcher = chokidar.watch(watchDir, { ignored: /(^|[/\\])\../, persistent: true, ignoreInitial: true }); watcher.on("add", () => { sendNotification(); }).on("unlink", () => { sendNotification(); }); };const transport = new StdioServerTransport();await server.connect(transport);initWatcher();`

## 28. mcp Promps

- 步骤: 创建文件->LLM-config 配置->新增 header xx -> 完整阶段视频->重要内容笔记, 重要内容暂停记录, 普通内容完成整一段后记录 ->代码->测试->更新笔记->部署;
